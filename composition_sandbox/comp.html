<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>untitled</title>
	<meta name="generator" content="TextMate http://macromates.com/">
	<meta name="author" content="Morgan Packard">
	<!-- Date: 2014-11-08 -->
	<script type="text/javascript" src="Tone.js"></script>
	<script>
	  
	  
	  function shuffle(array) {
      var currentIndex = array.length, temporaryValue, randomIndex ;

      // While there remain elements to shuffle...
      while (0 !== currentIndex) {

        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
      }

      return array;
    }
    
    // ==========================================
    // =                                        =
    // ==========================================
	  
	  var baseScale = [0, 2,3,5, 7, 9, 10];
	  
	  var scales = [
    ];
	  
	  
	  var addScale = function(offset) {
	    var newScale = [];
	    for(var i = 0; i < baseScale.length; i++){
	      newScale.push(baseScale[i] + offset);
	    }
	    scales.push(newScale);
	  }
	  var offsets = [0, -5, 0, -5, 0, -1];
	  for(var i = 0; i < offsets.length; i++){  
  	  addScale(offsets[i]);
	  }
	  

    var currentScale = 0;

    var scaleDegree = function(degree, noWrap) {
      var octave = Math.floor(degree / scales[currentScale].length);
      var baseNumber = degree % scales[currentScale].length;
      var ret = scales[currentScale][baseNumber] + 12 * octave;
      if(!noWrap){
        while(ret < 0){
          ret += 12;
        }
        while(ret > 24){
          ret -= 12;
        }
      }

      return ret;    
    }

    var NUM_ARPEGG_VOICES = 8;
 
     //arpeggios (room side A)
    var melodySequences = [];
    for(var seqIndex = 0; seqIndex < NUM_ARPEGG_VOICES; seqIndex++){
      var seq = []
      melodySequences.push(seq);
      
      for(var section = 0; section < 2 * scales.length; section ++){
        if(section % 2 == 0){
          currentScale = (currentScale + 1) % scales.length;
        }
        for(var i = 0; i < 32; i++){
          if(i == seqIndex * 2){
            seq.push(scaleDegree(i * 2))
          }else{
            seq.push("")
          }
        }
      }
    }
    // 
    // fast arpegg
    var fastArpeggSeq = [];
    sprinkles = [];

    currentScale = 0;
    for(var section = 0; section < 2 * scales.length; section ++){
      if(section % 2 == 0){
        currentScale = (currentScale + 1) % scales.length;
      }
      for(var i = 0; i < 32; i++){
        fastArpeggSeq.push(scaleDegree(i % 2+  i % 4 * 2, true) + 36);
      }
    }
    
    sprinkles.push(fastArpeggSeq);
    
    // "bass line" (room side B)
    currentScale = 0;
    var bassLine = [];
    var bassSequences = []
   for(var section = 0; section < 2 * scales.length; section ++){
      if(section % 2 == 0){
       currentScale = (currentScale + 1) % scales.length;
      }
       bassLine = bassLine.concat([
          scaleDegree(0) -12, "", "", "", scaleDegree(0)-12, "", "", "", scaleDegree(4)-12, "", "", "", scaleDegree(0)-12, "", "", "", 
        "", "", "", "","", "", "", "","", "", "", "","", "", "", "" 
      ])
    }
    
    bassSequences.push(bassLine);



    
    /////////////// NICK !!!! the sequences is in the sequences variable //////////////


    var sequences = melodySequences.concat(bassSequences).concat(sprinkles);
    

    console.log(JSON.stringify({melody:melodySequences, bass: bassSequences, sprinkles: sprinkles}, 3));
    
    // ====================================================================
    // =                    play back the sequences                       =
    // ====================================================================
    
    var release = 2 + Math.random() * 20;
    
    var keys = new Tone.PolySynth(3, Tone.MonoSynth, {
    		"oscType" : "square",
    		"filter" : {
    			"Q" : 0,
    			"type" : "lowpass",
    			"rolloff" : -24
    		},
    		"envelope" : {
    			"attack" : 0.005,
    			"decay" : 1,
    			"sustain" : 0,
    			"release" : release
    		},
    		"filterEnvelope" : {
    			"attack" : 2,
    			"decay" : 10,
    			"sustain" : 0,
    			"release" : release,
    			"min" : 20,
    			"max" : 4000
    		}
    	});
    	
    	
    //  
    // for(var voiceIndex = 0; voiceIndex < keys._voices; voiceIndex++){
    //   var voice = keys._voic
    //   var amplitudeLFO = new Tone.LFO(10, 0.05, 1);
    //      var ampAmount = new Tone.DryWet(1);
    //      var ampNode = Tone.context.createGain();
    //      keys.connect(ampNode);
    //      ampNode.connect(ampAmount.wet);
    //      keys.connect(ampAmount.dry);
    //      amplitudeLFO.connect(ampNode.gain);
    //      ampAmount.toMaster();
    // }
    //  
    // 
    // 
    //    
    
          
      var amplitudeLFO = new Tone.LFO(10, 0, 1);
         var ampAmount = new Tone.DryWet(1);
         var ampNode = Tone.context.createGain();
         keys.output.connect(ampNode);
         ampNode.connect(ampAmount.wet);
         keys.output.connect(ampAmount.dry);
         amplitudeLFO.connect(ampNode.gain);
         ampAmount.toMaster();
    
    

      //connect it to the master output
      // keys.toMaster();

    
    var bass = new Tone.PolySynth(3, Tone.MonoSynth, {
      		"oscType" : "square",
      		"filter" : {
      			"Q" : 0,
      			"type" : "lowpass",
      			"rolloff" : -24
      		},
      		"envelope" : {
      			"attack" : 0.005,
      			"decay" : 1,
      			"sustain" : 0,
      			"release" : 1
      		},
      		"filterEnvelope" : {
      			"attack" : 0.06,
      			"decay" : 10,
      			"sustain" : 1,
      			"release" : 2,
      			"min" : 20,
      			"max" : 4000
      		}
      	});
      	
    var sprinklesSynth = new Tone.PolySynth(3, Tone.MonoSynth, {
        		"oscType" : "square",
        		"filter" : {
        			"Q" : 0,
        			"type" : "lowpass",
        			"rolloff" : -24
        		},
        		"envelope" : {
        			"attack" : 0.005,
        			"decay" : 0.1,
        			"sustain" : 0,
        			"release" : 0.1
        		},
        		"filterEnvelope" : {
        			"attack" : 0.06,
        			"decay" : 10,
        			"sustain" : 1,
        			"release" : 2,
        			"min" : 20,
        			"max" : 4000
        		}
        	});
    
   // sprinklesSynth.toMaster();
    var feedbackDelay = new Tone.PingPongDelay(0.2);
    		//60% feedback
    		feedbackDelay.setFeedback(0.2);
    		//connections
    		sprinklesSynth.connect(feedbackDelay);
    		feedbackDelay.toMaster();	
    		feedbackDelay.setWet(0.2);


    
    
    
    window.keys = keys;
    
    var midiToFreq = function(midiNote){
      return 440 * Math.pow(2, (midiNote-69)/12);
    }
    
    bass.toMaster();
    
    var secsPer16th = 0.1;
    
    var Score = {};

    for(var i = 0; i < sprinkles.length; i++){
      var sequenceForThisVoice = sprinkles[i];
      var scoreForThisVoice = []
      Score["sprinkles" + i] = scoreForThisVoice;
      
      for(var step = 0; step < sequenceForThisVoice.length; step++){
        var thisStepVal = sequenceForThisVoice[step];
        if(thisStepVal !== ""){
          scoreForThisVoice.push(["0:0:" + step, [(1 + Math.random()*0.01) *  midiToFreq(50 + thisStepVal)]]);
        }
      }
      
      (function() {
        var voice = i;
        Tone.Note.route("sprinkles" + i, function(time, value){
        			var velocity = 1;
        			for (var note = 0; note < value.length; note++) {
                // console.log("voice " + voice);
        				sprinklesSynth.triggerAttackRelease(value[note], "16n", time, velocity);
        			}
        		});
        		
      })()      
    }


    		
    for(var i = 0; i < melodySequences.length; i++){
      var sequenceForThisVoice = melodySequences[i];
      var scoreForThisVoice = []
      Score["keys" + i] = scoreForThisVoice;
      
      for(var step = 0; step < sequenceForThisVoice.length; step++){
        var thisStepVal = sequenceForThisVoice[step];
        if(thisStepVal !== ""){
          scoreForThisVoice.push(["0:0:" + step, [(1 + Math.random()*0.01) *  midiToFreq(50 + thisStepVal)]]);
        }
      }
      
      (function() {
        var voice = i;
        Tone.Note.route("keys" + i, function(time, value){
        			var velocity = 1;
        			for (var note = 0; note < value.length; note++) {
                // console.log("voice " + voice);
        				keys.triggerAttackRelease(value[note], "16n", time, velocity);
        			}
        		});
        		
      })()      
    }
    		
    		
    		
    for(var i = 0; i < bassSequences.length; i++){
      var sequenceForThisVoice = bassSequences[i];
      var scoreForThisVoice = []
      Score["bass" + i] = scoreForThisVoice;
      
      for(var step = 0; step < sequenceForThisVoice.length; step++){
        var thisStepVal = sequenceForThisVoice[step];
        if(thisStepVal !== ""){
          scoreForThisVoice.push(["0:0:" + step, [(1 + Math.random()*0.01) *  midiToFreq(50 + thisStepVal)]]);
        }
      }
      
      (function() {
        var voice = i;
        Tone.Note.route("bass" + i, function(time, value){
        			var velocity = 1;
        			for (var note = 0; note < value.length; note++) {
                // console.log("voice " + voice);
        				bass.triggerAttackRelease(value[note], "16n", time, velocity);
        			}
        		});
        		
      })()      
    }
    

    	
    		//create events for all of the notes
    		Tone.Note.parseScore(Score)
    
    
    		Tone.Transport.setLoopStart(0);
    		Tone.Transport.setLoopEnd( secsPer16th * sequences[0].length  );
    		Tone.Transport.loop = true;
    		Tone.Transport.setBpm(120);
    		
    		Tone.Transport.start();
    
	</script>
</head>
<body id ="body">

<script>
document.getElementById("body").click = Tone.Transport.stop
</script>


</body>
</html>
